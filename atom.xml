<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StormCavalry</title>
  
  <subtitle>Hello ! My name is RenWei.</subtitle>
  <link href="/StormCavalry.github.io/atom.xml" rel="self"/>
  
  <link href="https://stormcavalry.github.io/"/>
  <updated>2020-03-27T12:38:07.739Z</updated>
  <id>https://stormcavalry.github.io/</id>
  
  <author>
    <name>RenWei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HashMap学习</title>
    <link href="https://stormcavalry.github.io/2020/03/27/hashmap/"/>
    <id>https://stormcavalry.github.io/2020/03/27/hashmap/</id>
    <published>2020-03-27T11:53:01.639Z</published>
    <updated>2020-03-27T12:38:07.739Z</updated>
    
    <content type="html"><![CDATA[<h3 id="hashmap结构"><a href="#hashmap结构" class="headerlink" title="hashmap结构"></a>hashmap结构</h3><p>hashmap 是数组+链表/红黑树<br>a.(当链表长度) &gt; 8 &amp; (数组长度) &gt;=64 转化为红黑树;<br>b.(红黑树节点) &lt; 6 转化为链表。</p><h3 id="hashmap初始化"><a href="#hashmap初始化" class="headerlink" title="hashmap初始化"></a>hashmap初始化</h3><p>初始化长度为16，负载因子为0.75</p><h3 id="hashmap插入流程"><a href="#hashmap插入流程" class="headerlink" title="hashmap插入流程"></a>hashmap插入流程</h3><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS85ZDkyZGRkYS1lZmRiLTRmZjctYTlmYi00MTFjMTY5MzNkYmMucG5n?x-oss-process=image/format,png" ></h2><p><a href="https://blog.csdn.net/zhengwangzw/article/details/104889549?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522158529225219725222452622%2522%252C%2522scm%2522%253A%252220140713.130056874..%2522%257D&request_id=158529225219725222452622&biz_id=0&utm_source=distribute.pc_search_result.none-task" target="_blank" rel="noopener">图片来源</a></p><hr>###### 注意：n - 1 & hash 是用来计算节点下标,n即为数组容量，hash即为 key 的 hash函数值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = n - <span class="number">1</span> &amp; hash]) == <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure>#### hash函数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h;</span><br><span class="line">       <span class="keyword">return</span> key == <span class="keyword">null</span> ? <span class="number">0</span> : (h = key.hashCode()) ^ h &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>首先我们可以看见hash函数值是可以为0的；hash函数值是 key哈希值的 高16位与低16位异或。###### 这样做的理由：a.位运算更高效;b.降低hash碰撞概率;<h6 id="为什么这样做可以降低hash碰撞？"><a href="#为什么这样做可以降低hash碰撞？" class="headerlink" title="为什么这样做可以降低hash碰撞？"></a>为什么这样做可以降低hash碰撞？</h6><p>这要回到我们给节点算的下标 n - 1 &amp; hash ; 无论hash函数值的高位如何，下标只会取数组容量的那低几位(因为总不可能把 key 的hashcode 放进来吧，内存不够的);这样的话散列并不好，这时，hash函数的作用就出来了,高16位与低16位异或，这样低位的随机性大大增强，散列性变好了，降低hash碰撞的概率了。 </p><h4 id="hashmap扩容"><a href="#hashmap扩容" class="headerlink" title="hashmap扩容"></a>hashmap扩容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (++<span class="keyword">this</span>.size &gt; <span class="keyword">this</span>.threshold) &#123;</span><br><span class="line">           <span class="keyword">this</span>.resize();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>当数组长度大于 容量*负载因子，就会扩容,每次扩容为原来的两倍。</p><h4 id="hashmap在1-8的优化"><a href="#hashmap在1-8的优化" class="headerlink" title="hashmap在1.8的优化"></a>hashmap在1.8的优化</h4><p>a.采用红黑树，时间复杂度由O(n)降为O(logn);<br>b.链表插入采用尾插法，避免成环;<br>c.扩容后位置不变或索引+旧容量大小；因为扩容都是2倍，在给下标的时候只会给低的几位。<br>d.先插入，再判断要不要扩容。</p><h4 id="hashmap是非线程安全的"><a href="#hashmap是非线程安全的" class="headerlink" title="hashmap是非线程安全的"></a>hashmap是非线程安全的</h4><p>hashmap可以覆盖数据，且在扩容时，也可能出现多个线程同时扩容的情况。</p><h6 id="解决：用-HashTable、Collections-synchronizedMap、以及ConcurrentHashMap"><a href="#解决：用-HashTable、Collections-synchronizedMap、以及ConcurrentHashMap" class="headerlink" title="解决：用 HashTable、Collections.synchronizedMap、以及ConcurrentHashMap"></a>解决：用 HashTable、Collections.synchronizedMap、以及ConcurrentHashMap</h6><h4 id="hashmap是无序的"><a href="#hashmap是无序的" class="headerlink" title="hashmap是无序的"></a>hashmap是无序的</h4><p>######有序的map:LinkedHashMap 和 TreeMap<br>LinkedHashMap内部维护了一个单链表，有头尾节点，同时LinkedHashMap节点Entry内部除了继承HashMap的Node属性，还有before 和 after用于标识前置节点和后置节点。可以实现按插入的顺序或访问顺序排序。<br>TreeMap是按照Key的自然顺序或者Comprator的顺序进行排序，内部是通过红黑树来实现。所以要么key所属的类实现Comparable接口，或者自定义一个实现了Comparator接口的比较器，传给TreeMap用户key的比较。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;hashmap结构&quot;&gt;&lt;a href=&quot;#hashmap结构&quot; class=&quot;headerlink&quot; title=&quot;hashmap结构&quot;&gt;&lt;/a&gt;hashmap结构&lt;/h3&gt;&lt;p&gt;hashmap 是数组+链表/红黑树&lt;br&gt;a.(当链表长度) &amp;gt; 8 &amp;am
      
    
    </summary>
    
    
    
      <category term="Java" scheme="https://stormcavalry.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>mybatis分页插件pagehelper查询数据总数,页数等不对的坑</title>
    <link href="https://stormcavalry.github.io/2020/03/10/mybatis%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6pagehelper%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E6%80%BB%E6%95%B0,%E9%A1%B5%E6%95%B0%E7%AD%89%E4%B8%8D%E5%AF%B9%E7%9A%84%E5%9D%91/"/>
    <id>https://stormcavalry.github.io/2020/03/10/mybatis%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6pagehelper%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E6%80%BB%E6%95%B0,%E9%A1%B5%E6%95%B0%E7%AD%89%E4%B8%8D%E5%AF%B9%E7%9A%84%E5%9D%91/</id>
    <published>2020-03-09T16:03:33.250Z</published>
    <updated>2020-03-09T16:25:56.704Z</updated>
    
    <content type="html"><![CDATA[<p> 在使用分页插件pagehelper的时候，出现了数据总数total总是和 Size 相同的情况。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PageInfo&lt;QuestionDto&gt; <span class="title">PushQuestion</span><span class="params">(Integer pageNo, Integer pageSize)</span></span>&#123;</span><br><span class="line">     PageHelper.startPage(pageNo,pageSize);</span><br><span class="line">     List&lt;Question&gt; questionList = questionMapper.findQuestion();</span><br><span class="line">     List&lt;QuestionDto&gt; questionDtoList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="keyword">if</span>(questionList!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">for</span> (Question question : questionList) &#123;</span><br><span class="line">             QuestionDto questionDto = <span class="keyword">new</span> QuestionDto();</span><br><span class="line">             BeanUtils.copyProperties(question,questionDto);</span><br><span class="line">             questionDtoList.add(questionDto);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     PageInfo&lt;QuestionDto&gt; pageInfo = <span class="keyword">new</span> PageInfo&lt;&gt;(questionDtoList);</span><br><span class="line">     <span class="keyword">return</span> pageInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 看了一下源码，他是这个样子的<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">PageInfo</span><span class="params">(List&lt;T&gt; list, <span class="keyword">int</span> navigatePages)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(list);</span><br><span class="line">       <span class="keyword">if</span> (list <span class="keyword">instanceof</span> Page) &#123;</span><br><span class="line">           Page page = (Page) list;</span><br><span class="line">           <span class="keyword">this</span>.pageNum = page.getPageNum();</span><br><span class="line">           <span class="keyword">this</span>.pageSize = page.getPageSize();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">this</span>.pages = page.getPages();</span><br><span class="line">           <span class="keyword">this</span>.size = page.size();</span><br><span class="line">           <span class="comment">//由于结果是&gt;startRow的，所以实际的需要+1</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.size == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">this</span>.startRow = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">this</span>.endRow = <span class="number">0</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">this</span>.startRow = page.getStartRow() + <span class="number">1</span>;</span><br><span class="line">               <span class="comment">//计算实际的endRow（最后一页的时候特殊）</span></span><br><span class="line">               <span class="keyword">this</span>.endRow = <span class="keyword">this</span>.startRow - <span class="number">1</span> + <span class="keyword">this</span>.size;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">           <span class="keyword">this</span>.pageNum = <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">this</span>.pageSize = list.size();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">this</span>.pages = <span class="keyword">this</span>.pageSize &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">this</span>.size = list.size();</span><br><span class="line">           <span class="keyword">this</span>.startRow = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">this</span>.endRow = list.size() &gt; <span class="number">0</span> ? list.size() - <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (list <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">           <span class="keyword">this</span>.navigatePages = navigatePages;</span><br><span class="line">           <span class="comment">//计算导航页</span></span><br><span class="line">           calcNavigatepageNums();</span><br><span class="line">           <span class="comment">//计算前后页，第一页，最后一页</span></span><br><span class="line">           calcPage();</span><br><span class="line">           <span class="comment">//判断页面边界</span></span><br><span class="line">           judgePageBoudary();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PageSerializable</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.list = list;</span><br><span class="line">       <span class="keyword">if</span>(list <span class="keyword">instanceof</span> Page)&#123;</span><br><span class="line">           <span class="keyword">this</span>.total = ((Page)list).getTotal();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.total = list.size();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br> 感情这些数据全是 list 去赋值的,当然 total 就和 Size相同了；相当于是我新建的对象questionDtoList破坏了page的属性。可以这样改：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PageInfo&lt;QuestionDto&gt; <span class="title">PushQuestion</span><span class="params">(Integer pageNo, Integer pageSize)</span></span>&#123;</span><br><span class="line">      PageHelper.startPage(pageNo,pageSize);</span><br><span class="line">      List&lt;Question&gt; questionList = questionMapper.findQuestion();</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里就将page正确的属性保留了下来</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      PageInfo&lt;Question&gt; page = <span class="keyword">new</span> PageInfo&lt;&gt;(questionList);</span><br><span class="line">      List&lt;QuestionDto&gt; questionDtoList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">if</span>(questionList!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">for</span> (Question question : questionList) &#123;</span><br><span class="line">              QuestionDto questionDto = <span class="keyword">new</span> QuestionDto();</span><br><span class="line">              BeanUtils.copyProperties(question,questionDto);</span><br><span class="line">              questionDtoList.add(questionDto);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      PageInfo&lt;QuestionDto&gt; pageInfo = <span class="keyword">new</span> PageInfo&lt;&gt;(questionDtoList);</span><br><span class="line">      BeanUtils.copyProperties(page,pageInfo);</span><br><span class="line">      <span class="keyword">return</span> pageInfo;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br> 根据调试，发现 questionList 对象是page的子类或者特定类的实例，这样就将正确的属性保留了下来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 在使用分页插件pagehelper的时候，出现了数据总数total总是和 Size 相同的情况。&lt;br&gt; &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line
      
    
    </summary>
    
    
    
      <category term="踩坑记录" scheme="https://stormcavalry.github.io/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>单链表反转和找环</title>
    <link href="https://stormcavalry.github.io/2020/03/02/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/"/>
    <id>https://stormcavalry.github.io/2020/03/02/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/</id>
    <published>2020-03-02T15:11:40.416Z</published>
    <updated>2020-03-02T16:27:59.542Z</updated>
    
    <content type="html"><![CDATA[<h4 id="反转方法1"><a href="#反转方法1" class="headerlink" title="反转方法1"></a>反转方法1</h4><p>创建一个有头节点的链表 head，原链表 listNode，创建一个链表 m 代替 listNode；<br>1.将m.next存起来，因为后面操作时m.next会改变；<br>2.将head.next 接给 m.next(实现反转)；<br>3.在将m接在 head.next下；<br>4.将存下来的m.next给m，重复操作；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">ListNode m = listNode;</span><br><span class="line"><span class="keyword">while</span>(m!=<span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">   ListNode n= m.next;</span><br><span class="line">    m.next=head.next;</span><br><span class="line">    head.next=m;</span><br><span class="line">    m=n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反转方法2"><a href="#反转方法2" class="headerlink" title="反转方法2"></a>反转方法2</h4><p>在原表 head 设立1个指针(m)，m指向head.next;<br>1.新建一个节点 n, 指向 m.next(n即要变换的节点);<br>2.n.next 接给 m.next(准备将n前移);<br>3.再把head.next 接给 n.next;<br>4.把n接到head后面，重复操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListNode m = head.next;</span><br><span class="line"><span class="keyword">while</span> (m.next != <span class="keyword">null</span> &amp;&amp; m != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ListNode n = m.next;</span><br><span class="line">    m.next = n.next;</span><br><span class="line">    n.next = head.next;</span><br><span class="line">    head.next = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单链表找环"><a href="#单链表找环" class="headerlink" title="单链表找环"></a>单链表找环</h4><p>用快慢指针的方法判断单链表是否有环是比较便捷的；快指针走两步，慢指针走一步，两个指针相等是，即代表有环，这个这可以画图证明；且起始节点到环起始节点的距离 等于 两指针交点到环起始节点的距离，这也是可以证明的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;反转方法1&quot;&gt;&lt;a href=&quot;#反转方法1&quot; class=&quot;headerlink&quot; title=&quot;反转方法1&quot;&gt;&lt;/a&gt;反转方法1&lt;/h4&gt;&lt;p&gt;创建一个有头节点的链表 head，原链表 listNode，创建一个链表 m 代替 listNode；&lt;br&gt;1.将
      
    
    </summary>
    
    
    
      <category term="leetcode" scheme="https://stormcavalry.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>非递归遍历二叉树</title>
    <link href="https://stormcavalry.github.io/2020/03/02/%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://stormcavalry.github.io/2020/03/02/%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-03-02T15:11:14.676Z</published>
    <updated>2020-03-02T16:37:30.835Z</updated>
    
    <content type="html"><![CDATA[<p>在进行二叉树遍历时，使用递归的方式来遍历是很简单的；我们可以采用非递归的方式来实现一下，即用一个栈来保存节点实现遍历(迭代)。</p><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>前序遍历顺序是 根-左-右；我们可以每一次都把根节点先处理，再先将右节点压栈，最后将左节点压栈，这样即可实现前序遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">s.push(root);</span><br><span class="line"><span class="keyword">while</span>(!s.empty())</span><br><span class="line">&#123;</span><br><span class="line">    TreeNode n = s.pop();</span><br><span class="line">   <span class="comment">//此时处理(打印或者存储)</span></span><br><span class="line">    <span class="keyword">if</span>(n.right!=<span class="keyword">null</span>)</span><br><span class="line">        s.push(n.right);</span><br><span class="line">    <span class="keyword">if</span>(n.left!=<span class="keyword">null</span>)</span><br><span class="line">        s.push(n.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>中序遍历顺序是 左-根-右；我们可以先把根节点压栈，然后在一直把左节点压栈，直到左节点无子节点；此时开始出栈，并处理，这时，我们可以判断该节点有无右节点，有的话，再进行压栈处理(和一开始一样)，这样便能实现中序遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;TreeNode&gt; s= <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line"> <span class="keyword">do</span>&#123;</span><br><span class="line">     <span class="keyword">while</span>(root!=<span class="keyword">null</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         s.push(root);</span><br><span class="line">         root=root.left;</span><br><span class="line">     &#125;</span><br><span class="line">     TreeNode t =  s.pop();</span><br><span class="line">     <span class="comment">//此时处理(打印或者存储)</span></span><br><span class="line">     <span class="keyword">if</span>(t.right!=<span class="keyword">null</span>)</span><br><span class="line">         root=t.right;</span><br><span class="line"></span><br><span class="line"> &#125;<span class="keyword">while</span>(!s.empty()||root!=<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>后序遍历顺序是 左-右-根；因为栈的特征是先进后出，我们用两个栈，一个表示原树，另一位用来存储；我们先把根节点入栈，因为我们要先把右边的入栈，在将左边的入栈，所有先处理右边，在处理左边即可。也可以这样理解，前序遍历是 根-左-右，后序遍历倒过来 根-右-左，压栈就类似于倒过来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">Stack&lt;TreeNode&gt; s1= <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">s.push(root);</span><br><span class="line"><span class="keyword">while</span>(!s.empty())</span><br><span class="line">&#123;</span><br><span class="line">   TreeNode n=s.pop();</span><br><span class="line">    s1.push(n);</span><br><span class="line">    <span class="keyword">if</span>(n.left!=<span class="keyword">null</span>)</span><br><span class="line">        s.push(n.left);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(n.right!=<span class="keyword">null</span>)</span><br><span class="line">        s.push(n.right);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//最后再进行处理</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在进行二叉树遍历时，使用递归的方式来遍历是很简单的；我们可以采用非递归的方式来实现一下，即用一个栈来保存节点实现遍历(迭代)。&lt;/p&gt;
&lt;h4 id=&quot;前序遍历&quot;&gt;&lt;a href=&quot;#前序遍历&quot; class=&quot;headerlink&quot; title=&quot;前序遍历&quot;&gt;&lt;/a&gt;前序遍
      
    
    </summary>
    
    
    
      <category term="leetcode" scheme="https://stormcavalry.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 归并排序</title>
    <link href="https://stormcavalry.github.io/2020/03/01/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://stormcavalry.github.io/2020/03/01/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2020-03-01T06:44:01.186Z</published>
    <updated>2020-03-01T06:56:41.059Z</updated>
    
    <content type="html"><![CDATA[<h5 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h5><p>  在O(n log n)的时间内使用常数级空间复杂度对链表进行排序，用归并排序来解决快速且稳定；归并排序即先使每个子序列有序，再使子序列段间有序；将已有序的子序列合并，得到完全有序的序列。</p><h5 id="递归得到子序列"><a href="#递归得到子序列" class="headerlink" title="递归得到子序列"></a>递归得到子序列</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 找中点</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     ListNode first=head;</span><br><span class="line">     ListNode last=head;</span><br><span class="line">     <span class="keyword">while</span>(first.next!=<span class="keyword">null</span>&amp;&amp;first.next.next!=<span class="keyword">null</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         first=first.next.next;</span><br><span class="line">         last=last.next;</span><br><span class="line">     &#125;</span><br><span class="line">     ListNode mid =last.next;</span><br><span class="line">     <span class="comment">//断开链表</span></span><br><span class="line">     last.next=<span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">return</span> merge(sortList(head),sortList(mid));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="合并子序列"><a href="#合并子序列" class="headerlink" title="合并子序列"></a>合并子序列</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode a,ListNode b)</span></span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 给定一个头节点</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode m = head;</span><br><span class="line">        <span class="keyword">while</span>(a!=<span class="keyword">null</span>&amp;&amp;b!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 从小到大排列</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span>(a.val&lt;b.val)</span><br><span class="line">            &#123;</span><br><span class="line">                m.next=a;</span><br><span class="line">                a=a.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                m.next=b;</span><br><span class="line">                b=b.next;</span><br><span class="line">            &#125;</span><br><span class="line">            m=m.next;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 看谁不为空，就代表它更大，应该排在后面</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">          <span class="keyword">if</span>(a!=<span class="keyword">null</span>) m.next=a;</span><br><span class="line">            <span class="keyword">else</span> m.next=b;</span><br><span class="line">            <span class="comment">//去掉头节点</span></span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;基本思路&quot;&gt;&lt;a href=&quot;#基本思路&quot; class=&quot;headerlink&quot; title=&quot;基本思路&quot;&gt;&lt;/a&gt;基本思路&lt;/h5&gt;&lt;p&gt;  在O(n log n)的时间内使用常数级空间复杂度对链表进行排序，用归并排序来解决快速且稳定；归并排序即先使每个子序列有
      
    
    </summary>
    
    
    
      <category term="leetcode" scheme="https://stormcavalry.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>第一天记录</title>
    <link href="https://stormcavalry.github.io/2020/02/29/Hello!%20%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>https://stormcavalry.github.io/2020/02/29/Hello!%20%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-02-29T12:50:10.605Z</published>
    <updated>2020-02-29T12:53:48.266Z</updated>
    
    <content type="html"><![CDATA[<ul><li>第一次搭建博客，是基于<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a>搭建的，希望以后能坚持写博客。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;第一次搭建博客，是基于&lt;a href=&quot;https://hexo.io/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo&lt;/a&gt;搭建的，希望以后能坚持写博客。&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
    
  </entry>
  
</feed>
