[{"title":"mybatis分页插件pagehelper查询数据总数,页数等不对的坑","url":"/StormCavalry.github.io/2020/03/10/mybatis%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6pagehelper%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E6%80%BB%E6%95%B0,%E9%A1%B5%E6%95%B0%E7%AD%89%E4%B8%8D%E5%AF%B9%E7%9A%84%E5%9D%91/","content":"<p> 在使用分页插件pagehelper的时候，出现了数据总数total总是和 Size 相同的情况。<br> <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PageInfo&lt;QuestionDto&gt; <span class=\"title\">PushQuestion</span><span class=\"params\">(Integer pageNo, Integer pageSize)</span></span>&#123;</span><br><span class=\"line\">     PageHelper.startPage(pageNo,pageSize);</span><br><span class=\"line\">     List&lt;Question&gt; questionList = questionMapper.findQuestion();</span><br><span class=\"line\">     List&lt;QuestionDto&gt; questionDtoList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(questionList!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (Question question : questionList) &#123;</span><br><span class=\"line\">             QuestionDto questionDto = <span class=\"keyword\">new</span> QuestionDto();</span><br><span class=\"line\">             BeanUtils.copyProperties(question,questionDto);</span><br><span class=\"line\">             questionDtoList.add(questionDto);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     PageInfo&lt;QuestionDto&gt; pageInfo = <span class=\"keyword\">new</span> PageInfo&lt;&gt;(questionDtoList);</span><br><span class=\"line\">     <span class=\"keyword\">return</span> pageInfo;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br> 看了一下源码，他是这个样子的<br> <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PageInfo</span><span class=\"params\">(List&lt;T&gt; list, <span class=\"keyword\">int</span> navigatePages)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">super</span>(list);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (list <span class=\"keyword\">instanceof</span> Page) &#123;</span><br><span class=\"line\">           Page page = (Page) list;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.pageNum = page.getPageNum();</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.pageSize = page.getPageSize();</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">this</span>.pages = page.getPages();</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.size = page.size();</span><br><span class=\"line\">           <span class=\"comment\">//由于结果是&gt;startRow的，所以实际的需要+1</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.size == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.startRow = <span class=\"number\">0</span>;</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.endRow = <span class=\"number\">0</span>;</span><br><span class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.startRow = page.getStartRow() + <span class=\"number\">1</span>;</span><br><span class=\"line\">               <span class=\"comment\">//计算实际的endRow（最后一页的时候特殊）</span></span><br><span class=\"line\">               <span class=\"keyword\">this</span>.endRow = <span class=\"keyword\">this</span>.startRow - <span class=\"number\">1</span> + <span class=\"keyword\">this</span>.size;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (list <span class=\"keyword\">instanceof</span> Collection) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.pageNum = <span class=\"number\">1</span>;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.pageSize = list.size();</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">this</span>.pages = <span class=\"keyword\">this</span>.pageSize &gt; <span class=\"number\">0</span> ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.size = list.size();</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.startRow = <span class=\"number\">0</span>;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.endRow = list.size() &gt; <span class=\"number\">0</span> ? list.size() - <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (list <span class=\"keyword\">instanceof</span> Collection) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.navigatePages = navigatePages;</span><br><span class=\"line\">           <span class=\"comment\">//计算导航页</span></span><br><span class=\"line\">           calcNavigatepageNums();</span><br><span class=\"line\">           <span class=\"comment\">//计算前后页，第一页，最后一页</span></span><br><span class=\"line\">           calcPage();</span><br><span class=\"line\">           <span class=\"comment\">//判断页面边界</span></span><br><span class=\"line\">           judgePageBoudary();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PageSerializable</span><span class=\"params\">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.list = list;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(list <span class=\"keyword\">instanceof</span> Page)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.total = ((Page)list).getTotal();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.total = list.size();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure><br> 感情这些数据全是 list 去赋值的,当然 total 就和 Size相同了；相当于是我新建的对象questionDtoList破坏了page的属性。可以这样改：<br> <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PageInfo&lt;QuestionDto&gt; <span class=\"title\">PushQuestion</span><span class=\"params\">(Integer pageNo, Integer pageSize)</span></span>&#123;</span><br><span class=\"line\">      PageHelper.startPage(pageNo,pageSize);</span><br><span class=\"line\">      List&lt;Question&gt; questionList = questionMapper.findQuestion();</span><br><span class=\"line\">      <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        这里就将page正确的属性保留了下来</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">      PageInfo&lt;Question&gt; page = <span class=\"keyword\">new</span> PageInfo&lt;&gt;(questionList);</span><br><span class=\"line\">      List&lt;QuestionDto&gt; questionDtoList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(questionList!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (Question question : questionList) &#123;</span><br><span class=\"line\">              QuestionDto questionDto = <span class=\"keyword\">new</span> QuestionDto();</span><br><span class=\"line\">              BeanUtils.copyProperties(question,questionDto);</span><br><span class=\"line\">              questionDtoList.add(questionDto);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      PageInfo&lt;QuestionDto&gt; pageInfo = <span class=\"keyword\">new</span> PageInfo&lt;&gt;(questionDtoList);</span><br><span class=\"line\">      BeanUtils.copyProperties(page,pageInfo);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> pageInfo;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><br> 根据调试，发现 questionList 对象是page的子类或者特定类的实例，这样就将正确的属性保留了下来。</p>\n","tags":["踩坑记录"]},{"title":"单链表反转和找环","url":"/StormCavalry.github.io/2020/03/02/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/","content":"<h4 id=\"反转方法1\"><a href=\"#反转方法1\" class=\"headerlink\" title=\"反转方法1\"></a>反转方法1</h4><p>创建一个有头节点的链表 head，原链表 listNode，创建一个链表 m 代替 listNode；<br>1.将m.next存起来，因为后面操作时m.next会改变；<br>2.将head.next 接给 m.next(实现反转)；<br>3.在将m接在 head.next下；<br>4.将存下来的m.next给m，重复操作；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ListNode head = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">ListNode m = listNode;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(m!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   ListNode n= m.next;</span><br><span class=\"line\">    m.next=head.next;</span><br><span class=\"line\">    head.next=m;</span><br><span class=\"line\">    m=n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"反转方法2\"><a href=\"#反转方法2\" class=\"headerlink\" title=\"反转方法2\"></a>反转方法2</h4><p>在原表 head 设立1个指针(m)，m指向head.next;<br>1.新建一个节点 n, 指向 m.next(n即要变换的节点);<br>2.n.next 接给 m.next(准备将n前移);<br>3.再把head.next 接给 n.next;<br>4.把n接到head后面，重复操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ListNode m = head.next;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (m.next != <span class=\"keyword\">null</span> &amp;&amp; m != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    ListNode n = m.next;</span><br><span class=\"line\">    m.next = n.next;</span><br><span class=\"line\">    n.next = head.next;</span><br><span class=\"line\">    head.next = n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"单链表找环\"><a href=\"#单链表找环\" class=\"headerlink\" title=\"单链表找环\"></a>单链表找环</h4><p>用快慢指针的方法判断单链表是否有环是比较便捷的；快指针走两步，慢指针走一步，两个指针相等是，即代表有环，这个这可以画图证明；且起始节点到环起始节点的距离 等于 两指针交点到环起始节点的距离，这也是可以证明的。</p>\n","tags":["leetcode"]},{"title":"非递归遍历二叉树","url":"/StormCavalry.github.io/2020/03/02/%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"<p>在进行二叉树遍历时，使用递归的方式来遍历是很简单的；我们可以采用非递归的方式来实现一下，即用一个栈来保存节点实现遍历(迭代)。</p>\n<h4 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h4><p>前序遍历顺序是 根-左-右；我们可以每一次都把根节点先处理，再先将右节点压栈，最后将左节点压栈，这样即可实现前序遍历。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stack&lt;TreeNode&gt; s = <span class=\"keyword\">new</span> Stack&lt;TreeNode&gt;();</span><br><span class=\"line\">s.push(root);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(!s.empty())</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TreeNode n = s.pop();</span><br><span class=\"line\">   <span class=\"comment\">//此时处理(打印或者存储)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n.right!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">        s.push(n.right);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n.left!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">        s.push(n.left);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h4><p>中序遍历顺序是 左-根-右；我们可以先把根节点压栈，然后在一直把左节点压栈，直到左节点无子节点；此时开始出栈，并处理，这时，我们可以判断该节点有无右节点，有的话，再进行压栈处理(和一开始一样)，这样便能实现中序遍历。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stack&lt;TreeNode&gt; s= <span class=\"keyword\">new</span> Stack&lt;TreeNode&gt;();</span><br><span class=\"line\"> <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">while</span>(root!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         s.push(root);</span><br><span class=\"line\">         root=root.left;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     TreeNode t =  s.pop();</span><br><span class=\"line\">     <span class=\"comment\">//此时处理(打印或者存储)</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span>(t.right!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">         root=t.right;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;<span class=\"keyword\">while</span>(!s.empty()||root!=<span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h4><p>后序遍历顺序是 左-右-根；因为栈的特征是先进后出，我们用两个栈，一个表示原树，另一位用来存储；我们先把根节点入栈，因为我们要先把右边的入栈，在将左边的入栈，所有先处理右边，在处理左边即可。也可以这样理解，前序遍历是 根-左-右，后序遍历倒过来 根-右-左，压栈就类似于倒过来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stack&lt;TreeNode&gt; s = <span class=\"keyword\">new</span> Stack&lt;TreeNode&gt;();</span><br><span class=\"line\">Stack&lt;TreeNode&gt; s1= <span class=\"keyword\">new</span> Stack&lt;TreeNode&gt;();</span><br><span class=\"line\">s.push(root);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(!s.empty())</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   TreeNode n=s.pop();</span><br><span class=\"line\">    s1.push(n);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n.left!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">        s.push(n.left);</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n.right!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">        s.push(n.right);</span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">//最后再进行处理</span></span><br></pre></td></tr></table></figure>","tags":["leetcode"]},{"title":"LeetCode 归并排序","url":"/StormCavalry.github.io/2020/03/01/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","content":"<h5 id=\"基本思路\"><a href=\"#基本思路\" class=\"headerlink\" title=\"基本思路\"></a>基本思路</h5><p>  在O(n log n)的时间内使用常数级空间复杂度对链表进行排序，用归并排序来解决快速且稳定；归并排序即先使每个子序列有序，再使子序列段间有序；将已有序的子序列合并，得到完全有序的序列。</p>\n<h5 id=\"递归得到子序列\"><a href=\"#递归得到子序列\" class=\"headerlink\" title=\"递归得到子序列\"></a>递归得到子序列</h5><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">sortList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">if</span>(head==<span class=\"keyword\">null</span>||head.next==<span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">     <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * 找中点</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">     ListNode first=head;</span><br><span class=\"line\">     ListNode last=head;</span><br><span class=\"line\">     <span class=\"keyword\">while</span>(first.next!=<span class=\"keyword\">null</span>&amp;&amp;first.next.next!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         first=first.next.next;</span><br><span class=\"line\">         last=last.next;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     ListNode mid =last.next;</span><br><span class=\"line\">     <span class=\"comment\">//断开链表</span></span><br><span class=\"line\">     last.next=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> merge(sortList(head),sortList(mid));</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"合并子序列\"><a href=\"#合并子序列\" class=\"headerlink\" title=\"合并子序列\"></a>合并子序列</h5><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ListNode <span class=\"title\">merge</span><span class=\"params\">(ListNode a,ListNode b)</span></span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * 给定一个头节点</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">        ListNode head = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode m = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(a!=<span class=\"keyword\">null</span>&amp;&amp;b!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * 从小到大排列</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a.val&lt;b.val)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                m.next=a;</span><br><span class=\"line\">                a=a.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                m.next=b;</span><br><span class=\"line\">                b=b.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m=m.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * 看谁不为空，就代表它更大，应该排在后面</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span>(a!=<span class=\"keyword\">null</span>) m.next=a;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> m.next=b;</span><br><span class=\"line\">            <span class=\"comment\">//去掉头节点</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> head.next;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n","tags":["leetcode"]},{"title":"第一天记录","url":"/StormCavalry.github.io/2020/02/29/Hello!%20%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/","content":"<ul>\n<li>第一次搭建博客，是基于<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">hexo</a>搭建的，希望以后能坚持写博客。</li>\n</ul>\n"}]