[{"title":"Linux虚拟机配置网络NAT模式","url":"/StormCavalry.github.io/2020/04/28/Linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9CNAT%E6%A8%A1%E5%BC%8F/","content":"<p>在VMware下装好了虚拟机后，我们就得让他能够连接外网和被外网访问。</p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>就俩步骤，简单的要死<br>1.虚拟机网络设置成NAT模式</p>\n<img src=\"https://img-blog.csdnimg.cn/20200428234336146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMDQ4Mw==,size_16,color_FFFFFF,t_70\" width=600>\n\n<p>2.更改配置文件</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost network-scripts]# vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure>\n<p>只需要将 onboot 改为 yes 即可</p>\n<img src=\"https://img-blog.csdnimg.cn/2020042823431667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMDQ4Mw==,size_16,color_FFFFFF,t_70\" width=400>\n\n<p>最后 reboot 重启一下</p>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>用命令 ifconfig 即可查看 当前分得的 ip<br>然后 ping 来 ping 去 试试就行了</p>\n","tags":["linux"]},{"title":"Linux下安装MySQL","url":"/StormCavalry.github.io/2020/04/28/Linux%E4%B8%8B%E5%AE%89%E8%A3%85MySQL/","content":"<p>还是用阿里云的数据库舒服，自己装还是麻烦一点点的。</p>\n<h3 id=\"1-清除以前的-mysql\"><a href=\"#1-清除以前的-mysql\" class=\"headerlink\" title=\"1.清除以前的 mysql\"></a>1.清除以前的 mysql</h3><p>可能以前有安装过的 mysql，再重新安装前，要先清除一下。</p>\n<h3 id=\"2-通过-yum-安装-mysql\"><a href=\"#2-通过-yum-安装-mysql\" class=\"headerlink\" title=\"2.通过 yum 安装 mysql\"></a>2.通过 yum 安装 mysql</h3><p>yum 来安装还是很简单的：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost src]# wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm </span><br><span class=\"line\">[root@localhost src]# rpm -ivh mysql57-community-release-el7-8.noarch.rpm </span><br><span class=\"line\">[root@localhost src]# yum -y install mysql-server</span><br></pre></td></tr></table></figure>\n<p>安装的时候还是比较慢，和网速有关，耐心等一会就行了。<br>这是默认安装的一些文件路径：<br>配置文件：/etc/my.cnf<br>日志文件：/var/log/var/log/mysqld.log<br>服务启动脚本：/usr/lib/systemd/system/mysqld.service<br>socket文件：/var/run/mysqld/mysqld.pid</p>\n<h4 id=\"3-更改密码\"><a href=\"#3-更改密码\" class=\"headerlink\" title=\"3.更改密码\"></a>3.更改密码</h4><p>安装完成之后就可以启动mysql了</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost src]# service mysqld restart</span><br></pre></td></tr></table></figure>\n<p>此时如果我们去登录一般情况下时登不进去了，我们要先配置<br>不用密码登录，进去了之后我们再改密码即可。<br>先去配置文件改一下 加上 skip-grant-tables，然后重启一下</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost src]# vim /etc/my.cnf</span><br></pre></td></tr></table></figure>\n<img src=\"https://img-blog.csdnimg.cn/20200428234533757.png\" width =300>\n\n<p>然后我们登录数据库</p>\n<p>此时我们再更改密码</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">user</span> <span class=\"string\">'root'</span>@<span class=\"string\">'localhost'</span> <span class=\"keyword\">identified</span> <span class=\"keyword\">by</span>  <span class=\"string\">'123'</span> //将密码改为<span class=\"number\">123</span>;</span><br></pre></td></tr></table></figure>\n<p>再去注释掉配置文件的 skip-grant-tables 就 ok了。</p>\n<h4 id=\"4-连接Navicat\"><a href=\"#4-连接Navicat\" class=\"headerlink\" title=\"4.连接Navicat\"></a>4.连接Navicat</h4><p>1.打开3306端口</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost src]# firewall-cmd --add-port=3306/tcp</span><br><span class=\"line\">[root@localhost src]# firewall-cmd --reload</span><br></pre></td></tr></table></figure>\n<p>2.改一下 user 表的 host</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; select user,host from user;</span><br></pre></td></tr></table></figure>\n<img src=\"https://img-blog.csdnimg.cn/20200428234609422.png\" width=400>\n\n<p>如果是 % 就 ok ，不是的话就改一下 host 为你的主机ip 或者 % 即可</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; update user set host = '%' where user = 'root';</span><br></pre></td></tr></table></figure>\n\n<p>测试连接<br><img src=\"https://img-blog.csdnimg.cn/20200428234623688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMDQ4Mw==,size_16,color_FFFFFF,t_70\" width=400><br><img src=\"https://img-blog.csdnimg.cn/20200428234634421.png\" width=200></p>\n<p>搞定</p>\n","tags":["linux"]},{"title":"LeetCode 位运算","url":"/StormCavalry.github.io/2020/03/30/LeetCode%20%E4%BD%8D%E8%BF%90%E7%AE%97/","content":"<p>今天在leetcode上刷到了位运算的题，一开始还真没反应过来，记录一下吧~~<br>题目都是关于:在数组中找出出现一次或者两次的元素，其他元素都出现了两次。</p>\n<h3 id=\"只出现一个数-只出现一次-的情况\"><a href=\"#只出现一个数-只出现一次-的情况\" class=\"headerlink\" title=\"只出现一个数(只出现一次)的情况\"></a>只出现一个数(只出现一次)的情况</h3><p>这个很简单，两个相同的数相异或的结果就是0，0与任何数异或就是这个数本身。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">singleNumbers</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : nums) &#123;</span><br><span class=\"line\">           a^=i;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"两个数-只出现一次-的情况\"><a href=\"#两个数-只出现一次-的情况\" class=\"headerlink\" title=\"两个数(只出现一次)的情况\"></a>两个数(只出现一次)的情况</h3><p>我们若能将数组分成两拨就好办了，俩不同的数异或，必然有位数是1，另一个是0，我们找<br>到那一位，将数组分成两拨即可。可以采用 n&amp;(-n)的方法，直接找到二进制数最低位的1，依此分组。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] singleNumbers(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a=<span class=\"number\">0</span>,x=<span class=\"number\">0</span>,y=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : nums) &#123;</span><br><span class=\"line\">            a^=i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> o=a&amp;(-a);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((num&amp;o)==o)</span><br><span class=\"line\">                x^=num;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                y^=num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;x,y&#125; ;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"一个数只出现一次，其他数出现三次\"><a href=\"#一个数只出现一次，其他数出现三次\" class=\"headerlink\" title=\"一个数只出现一次，其他数出现三次\"></a>一个数只出现一次，其他数出现三次</h3><p>这下子，异或就不太好使了，不过观察可以看出，3个相同的数，二进制的每一位加起来必然<br>是3的倍数，将数组每一位都加一遍，把不是3的位提出来，就是只出现一次的那个数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">singleNumbers</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">32</span>;i++)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          <span class=\"keyword\">int</span> count=<span class=\"number\">0</span>;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span>((num&amp;(<span class=\"number\">1</span>&lt;&lt;i))!=<span class=\"number\">0</span>) count++;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(count%<span class=\"number\">3</span>!=<span class=\"number\">0</span>) a+=(<span class=\"number\">1</span>&lt;&lt;i);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>","tags":["leetcode"]},{"title":"HashMap学习","url":"/StormCavalry.github.io/2020/03/27/hashmap/","content":"<h2 id=\"hashmap结构\"><a href=\"#hashmap结构\" class=\"headerlink\" title=\"hashmap结构\"></a>hashmap结构</h2><p>hashmap 是数组+链表/红黑树<br>a.(当链表长度) &gt; 8 &amp; (数组长度) &gt;=64 转化为红黑树;<br>b.(红黑树节点) &lt; 6 转化为链表。</p>\n<h2 id=\"hashmap初始化\"><a href=\"#hashmap初始化\" class=\"headerlink\" title=\"hashmap初始化\"></a>hashmap初始化</h2><p>初始化长度为16，负载因子为0.75</p>\n<h2 id=\"hashmap插入流程\"><a href=\"#hashmap插入流程\" class=\"headerlink\" title=\"hashmap插入流程\"></a>hashmap插入流程</h2><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"https://img-blog.csdnimg.cn/2020031712385760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poZW5nd2FuZ3p3,size_16,color_FFFFFF,t_70\" width=\"600\" ></h2><p><a href=\"https://blog.csdn.net/zhengwangzw/article/details/104889549?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522158529225219725222452622%2522%252C%2522scm%2522%253A%252220140713.130056874..%2522%257D&request_id=158529225219725222452622&biz_id=0&utm_source=distribute.pc_search_result.none-task\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<hr>\n#### 注意：n - 1 & hash 是用来计算节点下标,n即为数组容量，hash即为 key 的 hash函数值\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((p = tab[i = n - <span class=\"number\">1</span> &amp; hash]) == <span class=\"keyword\">null</span>)</span><br></pre></td></tr></table></figure>\n## hash函数\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> key == <span class=\"keyword\">null</span> ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ h &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n首先我们可以看见hash函数值是可以为0的；hash函数值是 key哈希值的 高16位与低16位异或。\n#### 这样做的理由：\na.位运算更高效;\nb.降低hash碰撞概率;\n\n<h4 id=\"为什么这样做可以降低hash碰撞？\"><a href=\"#为什么这样做可以降低hash碰撞？\" class=\"headerlink\" title=\"为什么这样做可以降低hash碰撞？\"></a>为什么这样做可以降低hash碰撞？</h4><p>这要回到我们给节点算的下标 n - 1 &amp; hash ; 无论hash函数值的高位如何，下标只会取数组容量的那低几位(因为总不可能把 key 的hashcode 放进来吧，内存不够的);这样的话散列并不好，这时，hash函数的作用就出来了,高16位与低16位异或，这样低位的随机性大大增强，散列性变好了，降低hash碰撞的概率了。 </p>\n<h2 id=\"hashmap扩容\"><a href=\"#hashmap扩容\" class=\"headerlink\" title=\"hashmap扩容\"></a>hashmap扩容</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (++<span class=\"keyword\">this</span>.size &gt; <span class=\"keyword\">this</span>.threshold) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.resize();</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<p>当数组长度大于 容量*负载因子，就会扩容,每次扩容为原来的两倍。</p>\n<h2 id=\"hashmap在1-8的优化\"><a href=\"#hashmap在1-8的优化\" class=\"headerlink\" title=\"hashmap在1.8的优化\"></a>hashmap在1.8的优化</h2><p>a.采用红黑树，时间复杂度由O(n)降为O(logn);<br>b.链表插入采用尾插法，避免成环;<br>c.扩容后位置不变或索引+旧容量大小；因为扩容都是2倍，在给下标的时候只会给低的几位。<br>d.先插入，再判断要不要扩容。</p>\n<h2 id=\"hashmap是非线程安全的\"><a href=\"#hashmap是非线程安全的\" class=\"headerlink\" title=\"hashmap是非线程安全的\"></a>hashmap是非线程安全的</h2><p>hashmap可以覆盖数据，且在扩容时，也可能出现多个线程同时扩容的情况。</p>\n<h4 id=\"解决：用-HashTable、Collections-synchronizedMap、以及ConcurrentHashMap\"><a href=\"#解决：用-HashTable、Collections-synchronizedMap、以及ConcurrentHashMap\" class=\"headerlink\" title=\"解决：用 HashTable、Collections.synchronizedMap、以及ConcurrentHashMap\"></a>解决：用 HashTable、Collections.synchronizedMap、以及ConcurrentHashMap</h4><h2 id=\"hashmap是无序的\"><a href=\"#hashmap是无序的\" class=\"headerlink\" title=\"hashmap是无序的\"></a>hashmap是无序的</h2><p>######有序的map:LinkedHashMap 和 TreeMap<br>LinkedHashMap内部维护了一个单链表，有头尾节点，同时LinkedHashMap节点Entry内部除了继承HashMap的Node属性，还有before 和 after用于标识前置节点和后置节点。可以实现按插入的顺序或访问顺序排序。<br>TreeMap是按照Key的自然顺序或者Comprator的顺序进行排序，内部是通过红黑树来实现。所以要么key所属的类实现Comparable接口，或者自定义一个实现了Comparator接口的比较器，传给TreeMap用户key的比较。</p>\n","tags":["Java"]},{"title":"mybatis分页插件pagehelper查询数据总数,页数等不对的坑","url":"/StormCavalry.github.io/2020/03/10/mybatis%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6pagehelper%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E6%80%BB%E6%95%B0,%E9%A1%B5%E6%95%B0%E7%AD%89%E4%B8%8D%E5%AF%B9%E7%9A%84%E5%9D%91/","content":"<p> 在使用分页插件pagehelper的时候，出现了数据总数total总是和 Size 相同的情况。<br> <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PageInfo&lt;QuestionDto&gt; <span class=\"title\">PushQuestion</span><span class=\"params\">(Integer pageNo, Integer pageSize)</span></span>&#123;</span><br><span class=\"line\">     PageHelper.startPage(pageNo,pageSize);</span><br><span class=\"line\">     List&lt;Question&gt; questionList = questionMapper.findQuestion();</span><br><span class=\"line\">     List&lt;QuestionDto&gt; questionDtoList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(questionList!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (Question question : questionList) &#123;</span><br><span class=\"line\">             QuestionDto questionDto = <span class=\"keyword\">new</span> QuestionDto();</span><br><span class=\"line\">             BeanUtils.copyProperties(question,questionDto);</span><br><span class=\"line\">             questionDtoList.add(questionDto);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     PageInfo&lt;QuestionDto&gt; pageInfo = <span class=\"keyword\">new</span> PageInfo&lt;&gt;(questionDtoList);</span><br><span class=\"line\">     <span class=\"keyword\">return</span> pageInfo;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br> 看了一下源码，他是这个样子的<br> <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PageInfo</span><span class=\"params\">(List&lt;T&gt; list, <span class=\"keyword\">int</span> navigatePages)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">super</span>(list);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (list <span class=\"keyword\">instanceof</span> Page) &#123;</span><br><span class=\"line\">           Page page = (Page) list;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.pageNum = page.getPageNum();</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.pageSize = page.getPageSize();</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">this</span>.pages = page.getPages();</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.size = page.size();</span><br><span class=\"line\">           <span class=\"comment\">//由于结果是&gt;startRow的，所以实际的需要+1</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.size == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.startRow = <span class=\"number\">0</span>;</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.endRow = <span class=\"number\">0</span>;</span><br><span class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.startRow = page.getStartRow() + <span class=\"number\">1</span>;</span><br><span class=\"line\">               <span class=\"comment\">//计算实际的endRow（最后一页的时候特殊）</span></span><br><span class=\"line\">               <span class=\"keyword\">this</span>.endRow = <span class=\"keyword\">this</span>.startRow - <span class=\"number\">1</span> + <span class=\"keyword\">this</span>.size;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (list <span class=\"keyword\">instanceof</span> Collection) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.pageNum = <span class=\"number\">1</span>;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.pageSize = list.size();</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">this</span>.pages = <span class=\"keyword\">this</span>.pageSize &gt; <span class=\"number\">0</span> ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.size = list.size();</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.startRow = <span class=\"number\">0</span>;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.endRow = list.size() &gt; <span class=\"number\">0</span> ? list.size() - <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (list <span class=\"keyword\">instanceof</span> Collection) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.navigatePages = navigatePages;</span><br><span class=\"line\">           <span class=\"comment\">//计算导航页</span></span><br><span class=\"line\">           calcNavigatepageNums();</span><br><span class=\"line\">           <span class=\"comment\">//计算前后页，第一页，最后一页</span></span><br><span class=\"line\">           calcPage();</span><br><span class=\"line\">           <span class=\"comment\">//判断页面边界</span></span><br><span class=\"line\">           judgePageBoudary();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PageSerializable</span><span class=\"params\">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.list = list;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(list <span class=\"keyword\">instanceof</span> Page)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.total = ((Page)list).getTotal();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.total = list.size();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure><br> 感情这些数据全是 list 去赋值的,当然 total 就和 Size相同了；相当于是我新建的对象questionDtoList破坏了page的属性。可以这样改：<br> <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PageInfo&lt;QuestionDto&gt; <span class=\"title\">PushQuestion</span><span class=\"params\">(Integer pageNo, Integer pageSize)</span></span>&#123;</span><br><span class=\"line\">      PageHelper.startPage(pageNo,pageSize);</span><br><span class=\"line\">      List&lt;Question&gt; questionList = questionMapper.findQuestion();</span><br><span class=\"line\">      <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        这里就将page正确的属性保留了下来</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">      PageInfo&lt;Question&gt; page = <span class=\"keyword\">new</span> PageInfo&lt;&gt;(questionList);</span><br><span class=\"line\">      List&lt;QuestionDto&gt; questionDtoList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(questionList!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (Question question : questionList) &#123;</span><br><span class=\"line\">              QuestionDto questionDto = <span class=\"keyword\">new</span> QuestionDto();</span><br><span class=\"line\">              BeanUtils.copyProperties(question,questionDto);</span><br><span class=\"line\">              questionDtoList.add(questionDto);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      PageInfo&lt;QuestionDto&gt; pageInfo = <span class=\"keyword\">new</span> PageInfo&lt;&gt;(questionDtoList);</span><br><span class=\"line\">      BeanUtils.copyProperties(page,pageInfo);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> pageInfo;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><br> 根据调试，发现 questionList 对象是page的子类或者特定类的实例，这样就将正确的属性保留了下来。</p>\n","tags":["踩坑记录"]},{"title":"单链表反转和找环","url":"/StormCavalry.github.io/2020/03/02/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/","content":"<h2 id=\"反转方法1\"><a href=\"#反转方法1\" class=\"headerlink\" title=\"反转方法1\"></a>反转方法1</h2><p>创建一个有头节点的链表 head，原链表 listNode，创建一个链表 m 代替 listNode；<br>1.将m.next存起来，因为后面操作时m.next会改变；<br>2.将head.next 接给 m.next(实现反转)；<br>3.在将m接在 head.next下；<br>4.将存下来的m.next给m，重复操作；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ListNode head = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">ListNode m = listNode;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(m!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   ListNode n= m.next;</span><br><span class=\"line\">    m.next=head.next;</span><br><span class=\"line\">    head.next=m;</span><br><span class=\"line\">    m=n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"反转方法2\"><a href=\"#反转方法2\" class=\"headerlink\" title=\"反转方法2\"></a>反转方法2</h2><p>在原表 head 设立1个指针(m)，m指向head.next;<br>1.新建一个节点 n, 指向 m.next(n即要变换的节点);<br>2.n.next 接给 m.next(准备将n前移);<br>3.再把head.next 接给 n.next;<br>4.把n接到head后面，重复操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ListNode m = head.next;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (m.next != <span class=\"keyword\">null</span> &amp;&amp; m != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    ListNode n = m.next;</span><br><span class=\"line\">    m.next = n.next;</span><br><span class=\"line\">    n.next = head.next;</span><br><span class=\"line\">    head.next = n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"单链表找环\"><a href=\"#单链表找环\" class=\"headerlink\" title=\"单链表找环\"></a>单链表找环</h2><p>用快慢指针的方法判断单链表是否有环是比较便捷的；快指针走两步，慢指针走一步，两个指针相等是，即代表有环，这个这可以画图证明；且起始节点到环起始节点的距离 等于 两指针交点到环起始节点的距离，这也是可以证明的。</p>\n","tags":["leetcode"]},{"title":"非递归遍历二叉树","url":"/StormCavalry.github.io/2020/03/02/%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"<p>在进行二叉树遍历时，使用递归的方式来遍历是很简单的；我们可以采用非递归的方式来实现一下，即用一个栈来保存节点实现遍历(迭代)。</p>\n<h2 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h2><p>前序遍历顺序是 根-左-右；我们可以每一次都把根节点先处理，再先将右节点压栈，最后将左节点压栈，这样即可实现前序遍历。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stack&lt;TreeNode&gt; s = <span class=\"keyword\">new</span> Stack&lt;TreeNode&gt;();</span><br><span class=\"line\">s.push(root);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(!s.empty())</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TreeNode n = s.pop();</span><br><span class=\"line\">   <span class=\"comment\">//此时处理(打印或者存储)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n.right!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">        s.push(n.right);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n.left!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">        s.push(n.left);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h2><p>中序遍历顺序是 左-根-右；我们可以先把根节点压栈，然后在一直把左节点压栈，直到左节点无子节点；此时开始出栈，并处理，这时，我们可以判断该节点有无右节点，有的话，再进行压栈处理(和一开始一样)，这样便能实现中序遍历。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stack&lt;TreeNode&gt; s= <span class=\"keyword\">new</span> Stack&lt;TreeNode&gt;();</span><br><span class=\"line\"> <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">while</span>(root!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         s.push(root);</span><br><span class=\"line\">         root=root.left;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     TreeNode t =  s.pop();</span><br><span class=\"line\">     <span class=\"comment\">//此时处理(打印或者存储)</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span>(t.right!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">         root=t.right;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;<span class=\"keyword\">while</span>(!s.empty()||root!=<span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h2><p>后序遍历顺序是 左-右-根；因为栈的特征是先进后出，我们用两个栈，一个表示原树，另一位用来存储；我们先把根节点入栈，因为我们要先把右边的入栈，在将左边的入栈，所有先处理右边，在处理左边即可。也可以这样理解，前序遍历是 根-左-右，后序遍历倒过来 根-右-左，压栈就类似于倒过来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stack&lt;TreeNode&gt; s = <span class=\"keyword\">new</span> Stack&lt;TreeNode&gt;();</span><br><span class=\"line\">Stack&lt;TreeNode&gt; s1= <span class=\"keyword\">new</span> Stack&lt;TreeNode&gt;();</span><br><span class=\"line\">s.push(root);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(!s.empty())</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   TreeNode n=s.pop();</span><br><span class=\"line\">    s1.push(n);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n.left!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">        s.push(n.left);</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n.right!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">        s.push(n.right);</span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">//最后再进行处理</span></span><br></pre></td></tr></table></figure>","tags":["leetcode"]},{"title":"LeetCode 归并排序","url":"/StormCavalry.github.io/2020/03/01/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","content":"<h2 id=\"基本思路\"><a href=\"#基本思路\" class=\"headerlink\" title=\"基本思路\"></a>基本思路</h2><p>  在O(n log n)的时间内使用常数级空间复杂度对链表进行排序，用归并排序来解决快速且稳定；归并排序即先使每个子序列有序，再使子序列段间有序；将已有序的子序列合并，得到完全有序的序列。</p>\n<h2 id=\"递归得到子序列\"><a href=\"#递归得到子序列\" class=\"headerlink\" title=\"递归得到子序列\"></a>递归得到子序列</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">sortList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">if</span>(head==<span class=\"keyword\">null</span>||head.next==<span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">     <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * 找中点</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">     ListNode first=head;</span><br><span class=\"line\">     ListNode last=head;</span><br><span class=\"line\">     <span class=\"keyword\">while</span>(first.next!=<span class=\"keyword\">null</span>&amp;&amp;first.next.next!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         first=first.next.next;</span><br><span class=\"line\">         last=last.next;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     ListNode mid =last.next;</span><br><span class=\"line\">     <span class=\"comment\">//断开链表</span></span><br><span class=\"line\">     last.next=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> merge(sortList(head),sortList(mid));</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"合并子序列\"><a href=\"#合并子序列\" class=\"headerlink\" title=\"合并子序列\"></a>合并子序列</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ListNode <span class=\"title\">merge</span><span class=\"params\">(ListNode a,ListNode b)</span></span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * 给定一个头节点</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">        ListNode head = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode m = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(a!=<span class=\"keyword\">null</span>&amp;&amp;b!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * 从小到大排列</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a.val&lt;b.val)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                m.next=a;</span><br><span class=\"line\">                a=a.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                m.next=b;</span><br><span class=\"line\">                b=b.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m=m.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * 看谁不为空，就代表它更大，应该排在后面</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span>(a!=<span class=\"keyword\">null</span>) m.next=a;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> m.next=b;</span><br><span class=\"line\">            <span class=\"comment\">//去掉头节点</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> head.next;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n","tags":["leetcode"]},{"title":"第一天记录","url":"/StormCavalry.github.io/2020/02/29/Hello!%20%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/","content":"<ul>\n<li>第一次搭建博客，是基于<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">hexo</a>搭建的，希望以后能坚持写博客。</li>\n</ul>\n"}]