[{"title":"Linux虚拟机配置网络NAT模式","url":"/StormCavalry.github.io/2020/04/28/Linux虚拟机配置网络NAT模式 /","content":"在VMware下装好了虚拟机后，我们就得让他能够连接外网和被外网访问。\n### 配置\n就俩步骤，简单的要死\n1.虚拟机网络设置成NAT模式\n\n<img src=\"img/5.png\" width=600>\n\n2.更改配置文件\n```java\n[root@localhost network-scripts]# vim /etc/sysconfig/network-scripts/ifcfg-ens33\n```\n只需要将 onboot 改为 yes 即可\n\n<img src=\"img/7.png\" width=400>\n\n最后 reboot 重启一下\n\n### 测试\n用命令 ifconfig 即可查看 当前分得的 ip\n然后 ping 来 ping 去 试试就行了\n","tags":["linux"]},{"title":"Linux下安装MySQL","url":"/StormCavalry.github.io/2020/04/28/Linux下安装MySQL/","content":"还是用阿里云的数据库舒服，自己装还是麻烦一点点的。\n### 1.清除以前的 mysql\n可能以前有安装过的 mysql，再重新安装前，要先清除一下。\n### 2.通过 yum 安装 mysql\nyum 来安装还是很简单的：\n```java\n[root@localhost src]# wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm \n[root@localhost src]# rpm -ivh mysql57-community-release-el7-8.noarch.rpm \n[root@localhost src]# yum -y install mysql-server \n```\n安装的时候还是比较慢，和网速有关，耐心等一会就行了。\n这是默认安装的一些文件路径：\n配置文件：/etc/my.cnf \n日志文件：/var/log/var/log/mysqld.log \n服务启动脚本：/usr/lib/systemd/system/mysqld.service \nsocket文件：/var/run/mysqld/mysqld.pid\n#### 3.更改密码\n安装完成之后就可以启动mysql了\n```java\n[root@localhost src]# service mysqld restart \n```\n此时如果我们去登录一般情况下时登不进去了，我们要先配置\n不用密码登录，进去了之后我们再改密码即可。\n先去配置文件改一下 加上 skip-grant-tables，然后重启一下\n```java\n[root@localhost src]# vim /etc/my.cnf \n```\n<img src=\"img/1.png\" width =300>\n\n然后我们登录数据库\n\n此时我们再更改密码\n```sql\nalter user 'root'@'localhost' identified by  '123' //将密码改为123;\n```\n再去注释掉配置文件的 skip-grant-tables 就 ok了。\n\n#### 4.连接Navicat\n1.打开3306端口\n```java\n[root@localhost src]# firewall-cmd --add-port=3306/tcp\n[root@localhost src]# firewall-cmd --reload\n```\n2.改一下 user 表的 host\n```sql\nmysql> select user,host from user;\n```\n<img src=\"img/2.png\" width=400>\n\n如果是 % 就 ok ，不是的话就改一下 host 为你的主机ip 或者 % 即可\n```sql\nmysql> update user set host = '%' where user = 'root';\n```\n\n测试连接\n<img src=\"img/3.png\" width=400>\n<img src=\"img/4.png\" width=200>\n\n搞定\n\n\n\n\n\n","tags":["linux"]},{"title":"LeetCode 位运算","url":"/StormCavalry.github.io/2020/03/30/LeetCode 位运算/","content":"今天在leetcode上刷到了位运算的题，一开始还真没反应过来，记录一下吧~~\n题目都是关于:在数组中找出出现一次或者两次的元素，其他元素都出现了两次。\n### 只出现一个数(只出现一次)的情况\n这个很简单，两个相同的数相异或的结果就是0，0与任何数异或就是这个数本身。\n```java\n public int singleNumbers(int[] nums) {\n        int a = 0;\n        for (int i : nums) {\n            a^=i;\n        }\n        return a;\n    }\n```\n### 两个数(只出现一次)的情况\n我们若能将数组分成两拨就好办了，俩不同的数异或，必然有位数是1，另一个是0，我们找\n到那一位，将数组分成两拨即可。可以采用 n&(-n)的方法，直接找到二进制数最低位的1，依此分组。\n```java\npublic int[] singleNumbers(int[] nums) {\n        int a=0,x=0,y=0;\n        for (int i : nums) {\n            a^=i;\n        }\n        int o=a&(-a);\n        for (int num : nums) {\n            if((num&o)==o)\n                x^=num;\n            else\n                y^=num;\n        }\n        return new int[]{x,y} ;\n    }\n```\n### 一个数只出现一次，其他数出现三次\n这下子，异或就不太好使了，不过观察可以看出，3个相同的数，二进制的每一位加起来必然\n是3的倍数，将数组每一位都加一遍，把不是3的位提出来，就是只出现一次的那个数。\n```java\n public int singleNumbers(int[] nums) {\n       int a = 0;\n       for(int i=0;i<32;i++)\n       {\n           int count=0;\n           for (int num : nums) {\n               if((num&(1<<i))!=0) count++;\n           }\n           if(count%3!=0) a+=(1<<i);\n       }\n       return a;\n    }\n```","tags":["leetcode"]},{"title":"HashMap学习","url":"/StormCavalry.github.io/2020/03/27/hashmap/","content":"## hashmap结构\nhashmap 是数组+链表/红黑树\na.(当链表长度) > 8 & (数组长度) >=64 转化为红黑树;\nb.(红黑树节点) < 6 转化为链表。\n## hashmap初始化\n初始化长度为16，负载因子为0.75\n## hashmap插入流程\n## <img src=\"https://img-blog.csdnimg.cn/2020031712385760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poZW5nd2FuZ3p3,size_16,color_FFFFFF,t_70\" width=\"600\" >\n[图片来源](https://blog.csdn.net/zhengwangzw/article/details/104889549?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522158529225219725222452622%2522%252C%2522scm%2522%253A%252220140713.130056874..%2522%257D&request_id=158529225219725222452622&biz_id=0&utm_source=distribute.pc_search_result.none-task)\n<hr>\n#### 注意：n - 1 & hash 是用来计算节点下标,n即为数组容量，hash即为 key 的 hash函数值\n```java\nif ((p = tab[i = n - 1 & hash]) == null)\n```\n## hash函数\n```java\n static final int hash(Object key) {\n        int h;\n        return key == null ? 0 : (h = key.hashCode()) ^ h >>> 16;\n    }\n```\n首先我们可以看见hash函数值是可以为0的；hash函数值是 key哈希值的 高16位与低16位异或。\n#### 这样做的理由：\na.位运算更高效;\nb.降低hash碰撞概率;\n\n#### 为什么这样做可以降低hash碰撞？\n\n这要回到我们给节点算的下标 n - 1 & hash ; 无论hash函数值的高位如何，下标只会取数组容量的那低几位(因为总不可能把 key 的hashcode 放进来吧，内存不够的);这样的话散列并不好，这时，hash函数的作用就出来了,高16位与低16位异或，这样低位的随机性大大增强，散列性变好了，降低hash碰撞的概率了。 \n## hashmap扩容\n```java\n if (++this.size > this.threshold) {\n            this.resize();\n        }\n```\n当数组长度大于 容量*负载因子，就会扩容,每次扩容为原来的两倍。\n## hashmap在1.8的优化\na.采用红黑树，时间复杂度由O(n)降为O(logn);\nb.链表插入采用尾插法，避免成环;\nc.扩容后位置不变或索引+旧容量大小；因为扩容都是2倍，在给下标的时候只会给低的几位。\nd.先插入，再判断要不要扩容。\n## hashmap是非线程安全的\nhashmap可以覆盖数据，且在扩容时，也可能出现多个线程同时扩容的情况。\n#### 解决：用 HashTable、Collections.synchronizedMap、以及ConcurrentHashMap\n## hashmap是无序的\n######有序的map:LinkedHashMap 和 TreeMap\nLinkedHashMap内部维护了一个单链表，有头尾节点，同时LinkedHashMap节点Entry内部除了继承HashMap的Node属性，还有before 和 after用于标识前置节点和后置节点。可以实现按插入的顺序或访问顺序排序。\nTreeMap是按照Key的自然顺序或者Comprator的顺序进行排序，内部是通过红黑树来实现。所以要么key所属的类实现Comparable接口，或者自定义一个实现了Comparator接口的比较器，传给TreeMap用户key的比较。\n","tags":["Java"]},{"title":"mybatis分页插件pagehelper查询数据总数,页数等不对的坑","url":"/StormCavalry.github.io/2020/03/10/mybatis分页插件pagehelper查询数据总数,页数等不对的坑/","content":" 在使用分页插件pagehelper的时候，出现了数据总数total总是和 Size 相同的情况。\n ```java\n   public PageInfo<QuestionDto> PushQuestion(Integer pageNo, Integer pageSize){\n        PageHelper.startPage(pageNo,pageSize);\n        List<Question> questionList = questionMapper.findQuestion();\n        List<QuestionDto> questionDtoList = new ArrayList<>();\n        if(questionList!=null){\n            for (Question question : questionList) {\n                QuestionDto questionDto = new QuestionDto();\n                BeanUtils.copyProperties(question,questionDto);\n                questionDtoList.add(questionDto);\n            }\n        }\n        PageInfo<QuestionDto> pageInfo = new PageInfo<>(questionDtoList);\n        return pageInfo;\n   }\n ```\n 看了一下源码，他是这个样子的\n ```java\n  public PageInfo(List<T> list, int navigatePages) {\n        super(list);\n        if (list instanceof Page) {\n            Page page = (Page) list;\n            this.pageNum = page.getPageNum();\n            this.pageSize = page.getPageSize();\n\n            this.pages = page.getPages();\n            this.size = page.size();\n            //由于结果是>startRow的，所以实际的需要+1\n            if (this.size == 0) {\n                this.startRow = 0;\n                this.endRow = 0;\n            } else {\n                this.startRow = page.getStartRow() + 1;\n                //计算实际的endRow（最后一页的时候特殊）\n                this.endRow = this.startRow - 1 + this.size;\n            }\n        } else if (list instanceof Collection) {\n            this.pageNum = 1;\n            this.pageSize = list.size();\n\n            this.pages = this.pageSize > 0 ? 1 : 0;\n            this.size = list.size();\n            this.startRow = 0;\n            this.endRow = list.size() > 0 ? list.size() - 1 : 0;\n        }\n        if (list instanceof Collection) {\n            this.navigatePages = navigatePages;\n            //计算导航页\n            calcNavigatepageNums();\n            //计算前后页，第一页，最后一页\n            calcPage();\n            //判断页面边界\n            judgePageBoudary();\n        }\n    }\n public PageSerializable(List<T> list) {\n        this.list = list;\n        if(list instanceof Page){\n            this.total = ((Page)list).getTotal();\n        } else {\n            this.total = list.size();\n        }\n    }\n ```\n 感情这些数据全是 list 去赋值的,当然 total 就和 Size相同了；相当于是我新建的对象questionDtoList破坏了page的属性。可以这样改：\n ```java\n  public PageInfo<QuestionDto> PushQuestion(Integer pageNo, Integer pageSize){\n        PageHelper.startPage(pageNo,pageSize);\n        List<Question> questionList = questionMapper.findQuestion();\n        /*\n          这里就将page正确的属性保留了下来\n        */\n        PageInfo<Question> page = new PageInfo<>(questionList);\n        List<QuestionDto> questionDtoList = new ArrayList<>();\n        if(questionList!=null){\n            for (Question question : questionList) {\n                QuestionDto questionDto = new QuestionDto();\n                BeanUtils.copyProperties(question,questionDto);\n                questionDtoList.add(questionDto);\n            }\n        }\n        PageInfo<QuestionDto> pageInfo = new PageInfo<>(questionDtoList);\n        BeanUtils.copyProperties(page,pageInfo);\n        return pageInfo;\n   }\n ```\n 根据调试，发现 questionList 对象是page的子类或者特定类的实例，这样就将正确的属性保留了下来。","tags":["踩坑记录"]},{"title":"单链表反转和找环","url":"/StormCavalry.github.io/2020/03/02/单链表的反转/","content":"## 反转方法1\n创建一个有头节点的链表 head，原链表 listNode，创建一个链表 m 代替 listNode；\n1.将m.next存起来，因为后面操作时m.next会改变；\n2.将head.next 接给 m.next(实现反转)；\n3.在将m接在 head.next下；\n4.将存下来的m.next给m，重复操作；\n```java\n        ListNode head = new ListNode(0);\n        ListNode m = listNode;\n        while(m!=null)\n        {\n           ListNode n= m.next;\n            m.next=head.next;\n            head.next=m;\n            m=n;\n        }\n```\n## 反转方法2\n在原表 head 设立1个指针(m)，m指向head.next;\n1.新建一个节点 n, 指向 m.next(n即要变换的节点);\n2.n.next 接给 m.next(准备将n前移);\n3.再把head.next 接给 n.next;\n4.把n接到head后面，重复操作\n```java\n        ListNode m = head.next;\n        while (m.next != null && m != null) {\n            ListNode n = m.next;\n            m.next = n.next;\n            n.next = head.next;\n            head.next = n;\n        }\n```\n## 单链表找环\n用快慢指针的方法判断单链表是否有环是比较便捷的；快指针走两步，慢指针走一步，两个指针相等是，即代表有环，这个这可以画图证明；且起始节点到环起始节点的距离 等于 两指针交点到环起始节点的距离，这也是可以证明的。","tags":["leetcode"]},{"title":"非递归遍历二叉树","url":"/StormCavalry.github.io/2020/03/02/迭代遍历二叉树/","content":"在进行二叉树遍历时，使用递归的方式来遍历是很简单的；我们可以采用非递归的方式来实现一下，即用一个栈来保存节点实现遍历(迭代)。\n## 前序遍历\n前序遍历顺序是 根-左-右；我们可以每一次都把根节点先处理，再先将右节点压栈，最后将左节点压栈，这样即可实现前序遍历。\n```java\n        Stack<TreeNode> s = new Stack<TreeNode>();\n        s.push(root);\n        while(!s.empty())\n        {\n            TreeNode n = s.pop();\n           //此时处理(打印或者存储)\n            if(n.right!=null)\n                s.push(n.right);\n            if(n.left!=null)\n                s.push(n.left);\n        }\n```\n## 中序遍历\n中序遍历顺序是 左-根-右；我们可以先把根节点压栈，然后在一直把左节点压栈，直到左节点无子节点；此时开始出栈，并处理，这时，我们可以判断该节点有无右节点，有的话，再进行压栈处理(和一开始一样)，这样便能实现中序遍历。\n```java\n       Stack<TreeNode> s= new Stack<TreeNode>();\n        do{\n            while(root!=null)\n            {\n                s.push(root);\n                root=root.left;\n            }\n            TreeNode t =  s.pop();\n            //此时处理(打印或者存储)\n            if(t.right!=null)\n                root=t.right;\n\n        }while(!s.empty()||root!=null);\n```\n## 后序遍历\n后序遍历顺序是 左-右-根；因为栈的特征是先进后出，我们用两个栈，一个表示原树，另一位用来存储；我们先把根节点入栈，因为我们要先把右边的入栈，在将左边的入栈，所有先处理右边，在处理左边即可。也可以这样理解，前序遍历是 根-左-右，后序遍历倒过来 根-右-左，压栈就类似于倒过来。\n```java\n        Stack<TreeNode> s = new Stack<TreeNode>();\n        Stack<TreeNode> s1= new Stack<TreeNode>();\n        s.push(root);\n        while(!s.empty())\n        {\n           TreeNode n=s.pop();\n            s1.push(n);\n            if(n.left!=null)\n                s.push(n.left);\n           \n            if(n.right!=null)\n                s.push(n.right);\n        }  \n        //最后再进行处理\n```","tags":["leetcode"]},{"title":"LeetCode 归并排序","url":"/StormCavalry.github.io/2020/03/01/归并排序/","content":"## 基本思路\n  在O(n log n)的时间内使用常数级空间复杂度对链表进行排序，用归并排序来解决快速且稳定；归并排序即先使每个子序列有序，再使子序列段间有序；将已有序的子序列合并，得到完全有序的序列。\n## 递归得到子序列\n```java\n   public ListNode sortList(ListNode head) {\n\n        if(head==null||head.next==null) return head;\n        /**\n         * 找中点\n         */\n        ListNode first=head;\n        ListNode last=head;\n        while(first.next!=null&&first.next.next!=null)\n        {\n            first=first.next.next;\n            last=last.next;\n        }\n        ListNode mid =last.next;\n        //断开链表\n        last.next=null;\n        return merge(sortList(head),sortList(mid));\n    }\n```\n## 合并子序列\n```java\nprivate ListNode merge(ListNode a,ListNode b){\n      /**\n       * 给定一个头节点\n       */\n        ListNode head = new ListNode(0);\n        ListNode m = head;\n        while(a!=null&&b!=null)\n        {\n            /**\n             * 从小到大排列\n             */\n            if(a.val<b.val)\n            {\n                m.next=a;\n                a=a.next;\n            }\n            else\n            {\n                m.next=b;\n                b=b.next;\n            }\n            m=m.next;\n        }\n      /**\n       * 看谁不为空，就代表它更大，应该排在后面\n       */\n          if(a!=null) m.next=a;\n            else m.next=b;\n            //去掉头节点\n            return head.next;\n  }\n```\n","tags":["leetcode"]},{"title":"第一天记录","url":"/StormCavalry.github.io/2020/02/29/Hello! 我的博客/","content":"- 第一次搭建博客，是基于[hexo](https://hexo.io/zh-cn/)搭建的，希望以后能坚持写博客。"}]